{{{opensearch_license}}}
{{{generated_code_warning}}}

'use strict';

const { normalizeArguments{{#with_path_params}}, parsePathParam{{/with_path_params}}{{#required}}, handleMissingParam{{/required}} } = require('../utils');

/**
 * {{{method_description}}}
 * <br/> See Also: {{{reference}}}
 *
 * @memberOf {{{doc_namespace}}}
 *
 * @param {object} {{{params_container}}}{{{params_container_description}}}
 {{#parameter_descriptions}}
 * @param {{{type}}} {{{jsdoc_name}}} {{#deprecated}}DEPRECATED {{/deprecated}}{{{description}}}
 {{/parameter_descriptions}}
{{^params_container_description}}
 *
{{/params_container_description}}
 * @param {TransportRequestOptions} [options] - Options for {@link Transport#request}
 * @param {function} [callback] - Callback that handles errors and response
 *
 * @returns {{{return_type}}}
 */
function {{{function_name}}}(params, options, callback) {
  [params, options, callback] = normalizeArguments(params, options, callback);
  {{#required_params}}
  if (params.{{.}} == null) return handleMissingParam('{{.}}', this, callback);
  {{/required_params}}

  let { body, {{#path_params}}{{.}}, {{/path_params}}...querystring } = params;
  {{#path_params}}
  {{{.}}} = parsePathParam({{{.}}});
  {{/path_params}}

  {{#paths_are_uniform}}
  const path = {{{uniform_path}}};
  {{/paths_are_uniform}}
  {{^paths_are_uniform}}
  let path;
  {{#diverged_paths}}
  {{{guard}}}{{{condition}}} {
    path = {{{path}}};
  }{{/diverged_paths}}
  {{/paths_are_uniform}}
  const method = {{{http_verb}}};
  {{^body_required}}
  body = body || '';
  {{/body_required}}

  {{#bulk_body}}
  return this.transport.request({ method, path, querystring, bulkBody: body }, options, callback);
  {{/bulk_body}}
  {{^bulk_body}}
  return this.transport.request({ method, path, querystring, body }, options, callback);
  {{/bulk_body}}
}

module.exports = {{{function_name}}};
